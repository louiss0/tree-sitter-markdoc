(* Markdoc grammar sketch for this tree-sitter implementation. *)

source_file =
  frontmatter, { block_separator, block }, { blank_line | newline }
  | { newline }, [ block, { block_separator, block } ], { blank_line | newline } ;

block_separator = blank_line | newline ;

frontmatter = frontmatter_delimiter, newline, yaml, frontmatter_delimiter ;
frontmatter_delimiter = "---" ;

block =
  comment_block
  | markdoc_tag
  | fenced_code_block
  | heading
  | thematic_break
  | blockquote
  | html_block
  | unordered_list
  | ordered_list
  | html_comment
  | paragraph ;

heading = heading_marker, [ heading_text ] ;
heading_marker = ("#" | "##" | "###" | "####" | "#####" | "######"), ws1 ;

thematic_break = ("-" | "*" | "_"), { ws | "-" | "*" | "_" }, newline ;

blockquote = ">", { not_newline }, { newline, ">", { not_newline } } ;

(* Tags and expressions use {% %} delimiters (not {{ }}). *)
(* Block tags are line-based: the opening tag ends the line. *)
markdoc_tag = tag_self_close, line_break
            | tag_open, tag_body, tag_close ;

tag_body = { blank_line | block } ;

comment_block = "{%", ws, "comment", ws, "%}", { any }, "{%", ws, "/comment", ws, "%}" ;

tag_open = "{%", ws, tag_name, { tag_ws1, attribute }, tag_ws, "%}", line_break ;
tag_close = "{%", ws, "/", ws, tag_name, ws, "%}" ;
tag_self_close = "{%", ws, tag_name, { tag_ws1, attribute }, tag_ws, "/%}" ;

attribute = attribute_name, "=", attribute_value ;
attribute_value = value_expression ;

inline_expression = "{%", ws, (variable_value | call_expression), ws, "%}" ;

unordered_list = unordered_list_item, { unordered_list_item } ;
unordered_list_item =
  unordered_list_marker, list_paragraph, newline,
  { list_item_continuation | nested_unordered_list | nested_ordered_list } ;

ordered_list = ordered_list_item, { ordered_list_item } ;
ordered_list_item =
  ordered_list_marker, list_paragraph, newline,
  { list_item_continuation | nested_unordered_list | nested_ordered_list } ;

nested_unordered_list = nested_unordered_list_item, { nested_unordered_list_item } ;
nested_unordered_list_item =
  indented_unordered_list_marker, list_paragraph, newline,
  { list_item_continuation | nested_unordered_list | nested_ordered_list } ;

nested_ordered_list = nested_ordered_list_item, { nested_ordered_list_item } ;
nested_ordered_list_item =
  indented_ordered_list_marker, list_paragraph, newline,
  { list_item_continuation | nested_unordered_list | nested_ordered_list } ;

list_item_continuation = list_continuation, block ;

unordered_list_marker = list_marker ;
ordered_list_marker = list_marker ;
indented_unordered_list_marker = list_marker ;
indented_ordered_list_marker = list_marker ;
list_marker = { ws }, ("-" | "*" | "+" | digit, { digit }, "."), ws1 ;

paragraph = inline_first, { inline_content },
            { newline, inline_first, { inline_content } } ;

list_paragraph = paragraph ;

inline_first =
  inline_expression | inline_tag | text | html_inline | link
  | emphasis | strong | inline_code ;

inline_tag = tag_self_close ;

inline_content = inline_first | image | standalone_punct ;

value_expression = variable_value | call_expression | json_value ;
json_value = string | number | boolean | null | array_literal | object_literal ;

variable = "$", identifier ;
special_variable = "@", identifier ;
variable_reference = variable, { ".", identifier } ;
special_variable_reference = special_variable, { ".", identifier } ;
array_subscript = "[", ws, (number | string), ws, "]" ;
subscript_reference = (variable_reference | special_variable_reference), { array_subscript } ;
variable_value = variable_reference | special_variable_reference | subscript_reference ;

call_expression = identifier, "(", [ value_expression, { ws, ",", ws, value_expression } ], ")" ;
identifier = letter, { letter | digit | "_" } ;
string = "\"", { not_quote }, "\"" | "'", { not_single_quote }, "'" ;
number = [ "-" ], digit, { digit }, [ ".", digit, { digit } ] ;
boolean = "true" | "false" ;
null = "null" ;

tag_name = identifier ;
attribute_name = identifier ;
html_tag_name = identifier ;

array_literal = "[", ws, [ json_value, { ws, ",", ws, json_value }, [ ws, "," ] ], ws, "]" ;
object_literal = "{", ws, [ pair, { ws, ",", ws, pair }, [ ws, "," ] ], ws, "}" ;
pair = (identifier | string), ws, ":", ws, json_value ;

inline_code = "`", { not_backtick }, "`" ;
link = "[", link_text, "]", "(", link_destination, ")" ;
image = "![", image_alt, "]", "(", image_destination, ")" ;

html_comment = "<!--", { any }, "-->" ;
html_block = "<", html_tag_name, { any }, ">", { any }, "</", html_tag_name, ">"
           | "<", html_tag_name, { any }, "/>" ;
html_inline = html_block ;

line_break = blank_line | newline ;

ws = { " " | "\t" } ;
ws1 = ( " " | "\t" ), { " " | "\t" } ;
tag_ws = { " " | "\t" | "\r" | "\n" } ;
tag_ws1 = ( " " | "\t" | "\r" | "\n" ), { " " | "\t" | "\r" | "\n" } ;
newline = "\n" | "\r\n" ;
blank_line = newline, newline, { newline } ;

(* Helper terminals used in the sketch. *)
any = ? any character ? ;
not_newline = ? any character except newline ? ;
not_backtick = ? any character except backtick or newline ? ;
not_quote = ? any character except " or newline ? ;
not_single_quote = ? any character except ' or newline ? ;
letter = ? ASCII letter or underscore ? ;
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
yaml = { any } ;
